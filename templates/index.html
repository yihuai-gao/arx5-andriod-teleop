<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <style>
      body {
        background-color: #F0F0F0;
        font: 1rem/1.4 -apple-system, BlinkMacSystemFont,
          Segoe UI, Roboto, Oxygen,
          Ubuntu, Cantarell, Fira Sans,
          Droid Sans, Helvetica Neue, sans-serif;
      }

      header {
        padding: 0.5em;
        background-color: rgba(255, 255, 255, 0.90);
      }

      #stats {
        font-size: 1.25em;
        background-color: rgba(240, 240, 240, 0.5);
      }

      canvas {
        position: absolute;
        z-index: 0;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: 0;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <header></header>
      <p><span id="stats"></span></p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script type="text/javascript">
      class RTTStats {
        constructor(bufferSize) {
          this.bufferSize = bufferSize;
          this.bufferIndex = 0;
          this.rttArray = new Array(bufferSize).fill(0); // Initialize the circular buffer
        }

        calculate(rtt) {
          this.rttArray[this.bufferIndex] = rtt;
          this.bufferIndex = (this.bufferIndex + 1) % this.bufferSize;
          const minRtt = Math.min(...this.rttArray);
          const avgRtt = this.rttArray.reduce((acc, cur) => acc + cur, 0) / this.bufferSize;
          const maxRtt = Math.max(...this.rttArray);
          const stdDevRtt = Math.sqrt(this.rttArray.map(x => Math.pow(x - avgRtt, 2)).reduce((acc, cur) => acc + cur, 0) / this.bufferSize);
          return `${minRtt.toFixed(3)}/${avgRtt.toFixed(3)}/${maxRtt.toFixed(3)}/${stdDevRtt.toFixed(3)} ms`;
        }
      }
      const rttStats = new RTTStats(100);

      const socket = io();
      socket.on('echo', function(timestamp) {
        const rtt = Date.now() - timestamp;
        document.getElementById('stats').innerText = rttStats.calculate(rtt);
      });
    </script>
    <script type="module">
      import {WebXRButton} from '/static/js/webxr-button.js';

      // XR globals
      let xrButton = null;
      let xrRefSpace = null;

      // WebGL scene globals
      let gl = null;

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT  AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            xrButton.enabled = supported;
          });
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.getElementById('overlay') }
        }).then((session) => {
          xrButton.setSession(session);
          session.isImmersive = true;
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        const canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl', {
          xrCompatible: true
        });
        addCanvasListeners(gl.canvas);
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
        gl = null;
      }

      // Touch event handling
      let touchId;
      function addCanvasListeners(canvas) {
        canvas.addEventListener('touchstart', (event) => {
          if (touchId === undefined) {
            let touch = event.changedTouches[0];
            touchId = touch.identifier;
          }
        });

        canvas.addEventListener('touchmove', (event) => {
          for (let touch of event.changedTouches) {
            if (touchId === touch.identifier) {
              handleTouch(touch);
            }
          }
        });

        function updateTouchIds(event) {
          for (let touch of event.changedTouches) {
            if (touchId === touch.identifier) {
              touchId = undefined;
            }
          }
        }
        canvas.addEventListener('touchend', updateTouchIds);
        canvas.addEventListener('touchcancel', updateTouchIds);
      }

      function onXRFrame(t, frame) {
        frame.session.requestAnimationFrame(onXRFrame);

        // Visualize status of touch control
        const b = touchId !== undefined ? 0.25 : 0;
        gl.clearColor(0, 0, b, 0.5);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Send data to server
        const data = { timestamp: Date.now() };
        const pose = frame.getViewerPose(xrRefSpace);
        data.pose_valid = (pose !== null);
        
        if (touchId !== undefined) {
          const pose = frame.getViewerPose(xrRefSpace);
          if (pose) {
            data.position = {
              x: pose.transform.inverse.position.x,
              y: pose.transform.inverse.position.y,
              z: pose.transform.inverse.position.z,
            }
            data.orientation = {
              x: pose.transform.inverse.orientation.x,
              y: pose.transform.inverse.orientation.y,
              z: pose.transform.inverse.orientation.z,
              w: pose.transform.inverse.orientation.w,
            }
          }
        }
        socket.send(data);
      }

      initXR();
    </script>
  </body>
</html>
